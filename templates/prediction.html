{% extends "base.html" %}

{% block title %}予想を立てよう{% endblock %}

{% block content %}
<div class="chat-page">
    <div class="container-fluid">
        <div class="row">
            <!-- 左側: 対話画面 -->
            <div class="col-lg-7 chat-column">
                <div class="chat-header text-center mb-3">
                    <h2 class="mb-2">
                        <i class="fas fa-brain text-primary"></i>
                        予想を立てよう
                    </h2>
                    <div class="unit-display">
                        <span class="badge bg-primary fs-6">{{ unit }}</span>
                    </div>
                </div>
                
                <div class="task-section mb-3">
                    <div class="task-card">
                        <h5 class="task-title">
                            <i class="fas fa-clipboard-list"></i>
                            課題
                        </h5>
                        <p class="task-content">{{ task_content }}</p>
                    </div>
                </div>
                
                <div class="chat-container">
                    <div class="api-status" id="apiStatus" style="display: none;">
                        <div class="alert alert-warning">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span id="apiStatusMessage">AI接続を確認中...</span>
                            <button class="btn btn-sm btn-outline-secondary ms-2" onclick="testApiConnection()">
                                <i class="fas fa-sync"></i> 再テスト
                            </button>
                        </div>
                    </div>
                    
                    <div class="chat-messages" id="chatMessages">
                        <div class="message ai-message">
                            <div class="message-avatar"></div>
                            <div class="message-content">
                                {{ initial_ai_message }}
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="action-buttons text-center mt-3">
                    <button class="btn btn-success" id="summaryButton" style="display: none;">
                        <i class="fas fa-check me-2"></i>
                        予想をまとめる
                    </button>
                </div>
                
                <div class="summary-section" id="summarySection" style="display: none;">
                    <div class="summary-card">
                        <h5 class="summary-title">
                            <i class="fas fa-lightbulb"></i>
                            あなたの予想
                        </h5>
                        <div class="summary-content" id="summaryContent"></div>
                        <div class="text-center mt-3">
                            <a href="/experiment" class="btn btn-primary">
                                <i class="fas fa-flask me-2"></i>
                                実験を始める
                            </a>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 右側: 入力画面 -->
            <div class="col-lg-5 input-column">
                <div class="input-panel">
                    <div class="input-header mb-2">
                        <h4 class="mb-2" style="font-size: 1.1rem;">
                            <i class="fas fa-edit"></i> 入力エリア
                        </h4>
                        
                        <!-- 入力モード選択 -->
                        <div class="input-mode-selector mb-2">
                            <div class="btn-group btn-group-sm w-100" role="group">
                                <input type="radio" class="btn-check" name="inputMode" id="modeKeyboard" autocomplete="off" checked>
                                <label class="btn btn-outline-primary" for="modeKeyboard">
                                    <i class="fas fa-keyboard"></i> キーボード
                                </label>
                                
                                <input type="radio" class="btn-check" name="inputMode" id="modeFlick" autocomplete="off">
                                <label class="btn btn-outline-primary" for="modeFlick">
                                    <i class="fas fa-hand-pointer"></i> フリック
                                </label>
                                
                                <input type="radio" class="btn-check" name="inputMode" id="modeHandwriting" autocomplete="off">
                                <label class="btn btn-outline-primary" for="modeHandwriting">
                                    <i class="fas fa-pen"></i> 手書き
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- タッチキーボード -->
                    <div class="touch-keyboard-panel mb-2" id="touchKeyboard" style="display: block;">
                        <div class="keyboard-grid" id="hiraganaKeys">
                            <!-- JavaScriptで動的に生成 -->
                        </div>
                        <div class="keyboard-controls mt-1">
                            <button class="btn btn-sm btn-warning flex-fill me-1" id="backspaceBtn">
                                <i class="fas fa-backspace"></i> 消す
                            </button>
                            <button class="btn btn-sm btn-danger flex-fill" id="clearBtn">
                                <i class="fas fa-times"></i> 全消去
                            </button>
                        </div>
                    </div>
                    
                    <!-- フリック入力 -->
                    <div class="flick-keyboard-panel mb-2" id="flickKeyboard" style="display: none;">
                        <div class="flick-grid" id="flickKeys">
                            <!-- JavaScriptで動的に生成 -->
                        </div>
                        <div class="keyboard-controls mt-1">
                            <button class="btn btn-sm btn-warning flex-fill me-1" id="flickBackspaceBtn">
                                <i class="fas fa-backspace"></i> 消す
                            </button>
                            <button class="btn btn-sm btn-danger flex-fill" id="flickClearBtn">
                                <i class="fas fa-times"></i> 全消去
                            </button>
                        </div>
                    </div>
                    
                    <!-- 手書き入力 -->
                    <div class="handwriting-panel mb-2" id="handwritingPanel" style="display: none;">
                        <canvas id="handwritingCanvas" width="280" height="200" style="border: 2px solid #ddd; border-radius: 8px; background: white; cursor: crosshair; display: block; margin: 0 auto;"></canvas>
                        <div class="handwriting-controls mt-1">
                            <button class="btn btn-sm btn-success flex-fill me-1" id="recognizeBtn">
                                <i class="fas fa-check"></i> 認識
                            </button>
                            <button class="btn btn-sm btn-warning flex-fill me-1" id="clearCanvasBtn">
                                <i class="fas fa-eraser"></i> 消す
                            </button>
                        </div>
                        <div id="recognitionResult" class="mt-1 text-center" style="font-size: 0.85rem; color: #666;"></div>
                    </div>
                    
                    <!-- 音声入力ボタン -->
                    <div class="voice-input-section mb-2" id="voiceInputSection">
                        <button class="btn btn-outline-primary w-100 btn-sm" id="voiceInputBtn">
                            <i class="fas fa-microphone"></i> 音声で入力
                        </button>
                        <div class="voice-input-status mt-2" id="voiceInputStatus" style="display: none;">
                            <div class="alert alert-info mb-0 py-1">
                                <i class="fas fa-microphone"></i>
                                <span id="voiceStatusText">音声を認識中...</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- テキスト入力 -->
                    <div class="text-input-section">
                        <textarea class="form-control mb-2" id="messageInput" rows="3" placeholder="あなたの考えを入力してください..." style="font-size: 0.95rem;"></textarea>
                        <button class="btn btn-primary w-100 btn-sm" id="sendButton">
                            <i class="fas fa-paper-plane me-2"></i>送信
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let conversationCount = 0;
let lastMessage = '';

// 手書き入力用変数
let isDrawing = false;
let canvas, ctx;


// デジタル学習ツイン用の入力行動追跡
let inputBehaviorTracker = {
    startTime: null,
    keystrokes: [],
    pauses: 0,
    backspaces: 0,
    
    startTracking: function() {
        this.startTime = Date.now();
        this.keystrokes = [];
        this.pauses = 0;
        this.backspaces = 0;
    },
    
    recordKeystroke: function(key) {
        const now = Date.now();
        
        if (this.keystrokes.length > 0) {
            const timeSinceLastKey = now - this.keystrokes[this.keystrokes.length - 1].timestamp;
            if (timeSinceLastKey > 2000) { // 2秒以上の間隔はためらいとみなす
                this.pauses++;
            }
        }
        
        if (key === 'Backspace') {
            this.backspaces++;
        }
        
        this.keystrokes.push({
            key: key,
            timestamp: now
        });
    },
    
    getMetadata: function() {
        const totalTime = this.startTime ? (Date.now() - this.startTime) / 1000 : 0;
        const typingSpeed = this.keystrokes.length > 0 ? this.keystrokes.length / totalTime : 0;
        
        return {
            typing_speed: typingSpeed,
            pause_count: this.pauses,
            backspace_count: this.backspaces,
            thinking_time: totalTime
        };
    }
};

// 入力補助用の設定（シンプルなひらがなのみ）
const inputAssistConfig = {
    hiragana: [
        // あ行
        ['あ', 'い', 'う', 'え', 'お'],
        // か行
        ['か', 'き', 'く', 'け', 'こ'],
        // さ行
        ['さ', 'し', 'す', 'せ', 'そ'],
        // た行
        ['た', 'ち', 'つ', 'て', 'と'],
        // な行
        ['な', 'に', 'ぬ', 'ね', 'の'],
        // は行
        ['は', 'ひ', 'ふ', 'へ', 'ほ'],
        // ま行
        ['ま', 'み', 'む', 'め', 'も'],
        // や行
        ['や', '', 'ゆ', '', 'よ'],
        // ら行
        ['ら', 'り', 'る', 'れ', 'ろ'],
        // わ行
        ['わ', '', '', '', 'ん'],
        // 濁音・半濁音
        ['が', 'ぎ', 'ぐ', 'げ', 'ご'],
        ['ざ', 'じ', 'ず', 'ぜ', 'ぞ'],
        ['だ', 'ぢ', 'づ', 'で', 'ど'],
        ['ば', 'び', 'ぶ', 'べ', 'ぼ'],
        ['ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ'],
        // 小文字・記号
        ['っ', 'ゃ', 'ゅ', 'ょ', 'を'],
        ['。', '、', ' ', '', '']
    ],
    flick: {
        'あ': ['あ', 'い', 'う', 'え', 'お'],
        'か': ['か', 'き', 'く', 'け', 'こ'],
        'さ': ['さ', 'し', 'す', 'せ', 'そ'],
        'た': ['た', 'ち', 'つ', 'て', 'と'],
        'な': ['な', 'に', 'ぬ', 'ね', 'の'],
        'は': ['は', 'ひ', 'ふ', 'へ', 'ほ'],
        'ま': ['ま', 'み', 'む', 'め', 'も'],
        'や': ['や', '(', 'ゆ', ')', 'よ'],
        'ら': ['ら', 'り', 'る', 'れ', 'ろ'],
        'わ': ['わ', 'を', 'ん', 'ー', '〜'],
        '゛': ['゛', 'が', 'ぎ', 'ぐ', 'げ', 'ご', 'ざ', 'じ', 'ず', 'ぜ', 'ぞ', 'だ', 'ぢ', 'づ', 'で', 'ど', 'ば', 'び', 'ぶ', 'べ', 'ぼ'],
        '゜': ['゜', 'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ'],
        '、': ['、', '。', '!', '?', '…'],
        '☆': ['っ', 'ゃ', 'ゅ', 'ょ', 'ゎ']
    }
};

const currentUnit = "{{ unit }}";
let recognition = null;

// ページ読み込み時にAPI接続をテスト
document.addEventListener('DOMContentLoaded', function() {
    testApiConnection();
    
    // 入力補助の初期化
    initializeInputAssist();
    initializeFlickInput();
    initializeHandwriting();
    
    // 入力モード切り替え
    document.querySelectorAll('input[name="inputMode"]').forEach(radio => {
        radio.addEventListener('change', switchInputMode);
    });
    
    // 入力フィールドにイベントリスナーを追加
    const messageInput = document.getElementById('messageInput');
    
    messageInput.addEventListener('focus', function() {
        inputBehaviorTracker.startTracking();
    });
    
    messageInput.addEventListener('keydown', function(e) {
        inputBehaviorTracker.recordKeystroke(e.key);
    });
    
    // 入力補助トグル
    document.getElementById('inputAssistToggle').addEventListener('change', function(e) {
        toggleInputAssist(e.target.checked);
    });
    
    // 音声入力ボタン
    document.getElementById('voiceInputBtn').addEventListener('click', startVoiceInput);
    
    // キーボードコントロールボタン
    document.getElementById('backspaceBtn').addEventListener('click', function() {
        const input = document.getElementById('messageInput');
        input.value = input.value.slice(0, -1);
        input.focus();
    });
    
    document.getElementById('clearBtn').addEventListener('click', function() {
        document.getElementById('messageInput').value = '';
        document.getElementById('messageInput').focus();
    });
});

// 入力補助の初期化
function initializeInputAssist() {
    // ひらがなキーボードを設定（5列グリッドレイアウト）
    const hiraganaContainer = document.getElementById('hiraganaKeys');
    hiraganaContainer.innerHTML = '';
    
    inputAssistConfig.hiragana.forEach(row => {
        row.forEach(char => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn btn-outline-primary touch-key';
            if (char === '') {
                // 空白セル
                btn.style.visibility = 'hidden';
                btn.textContent = ' ';
            } else {
                btn.textContent = char;
                btn.onclick = () => insertText(char);
            }
            hiraganaContainer.appendChild(btn);
        });
    });
}

// 入力補助の表示切り替え
function toggleInputAssist(enabled) {
    const keyboardDiv = document.getElementById('touchKeyboard');
    const voiceDiv = document.getElementById('voiceInputSection');
    
    if (enabled) {
        keyboardDiv.style.display = 'block';
        voiceDiv.style.display = 'block';
    } else {
        keyboardDiv.style.display = 'none';
        voiceDiv.style.display = 'none';
        stopVoiceInput();
    }
}

// テキストを挿入
function insertText(text) {
    const input = document.getElementById('messageInput');
    input.value += text;
    input.focus();
}

// 音声入力開始
function startVoiceInput() {
    // Web Speech API のサポート確認
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert('お使いのブラウザは音声入力に対応していません。Chrome、Edge、Safariをお使いください。');
        return;
    }
    
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    
    if (recognition && recognition.isListening) {
        stopVoiceInput();
        return;
    }
    
    recognition = new SpeechRecognition();
    recognition.lang = 'ja-JP';
    recognition.continuous = false;
    recognition.interimResults = true;
    
    const statusDiv = document.getElementById('voiceInputStatus');
    const statusText = document.getElementById('voiceStatusText');
    const voiceBtn = document.getElementById('voiceInputBtn');
    
    recognition.onstart = function() {
        recognition.isListening = true;
        statusDiv.style.display = 'block';
        statusText.textContent = '音声を認識中...';
        voiceBtn.classList.add('btn-danger');
        voiceBtn.classList.remove('btn-outline-primary');
    };
    
    recognition.onresult = function(event) {
        let interimTranscript = '';
        let finalTranscript = '';
        
        for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
                finalTranscript += transcript;
            } else {
                interimTranscript += transcript;
            }
        }
        
        if (interimTranscript) {
            statusText.textContent = '認識中: ' + interimTranscript;
        }
        
        if (finalTranscript) {
            const input = document.getElementById('messageInput');
            input.value += finalTranscript;
            statusText.textContent = '認識完了: ' + finalTranscript;
        }
    };
    
    recognition.onerror = function(event) {
        console.error('音声認識エラー:', event.error);
        statusDiv.style.display = 'none';
        voiceBtn.classList.remove('btn-danger');
        voiceBtn.classList.add('btn-outline-primary');
        recognition.isListening = false;
        
        if (event.error === 'no-speech') {
            alert('音声が検出されませんでした。もう一度お試しください。');
        } else if (event.error === 'not-allowed') {
            alert('マイクの使用が許可されていません。ブラウザの設定を確認してください。');
        }
    };
    
    recognition.onend = function() {
        setTimeout(() => {
            statusDiv.style.display = 'none';
            voiceBtn.classList.remove('btn-danger');
            voiceBtn.classList.add('btn-outline-primary');
            recognition.isListening = false;
        }, 1000);
    };
    
    recognition.start();
}

// 音声入力停止
function stopVoiceInput() {
    if (recognition && recognition.isListening) {
        recognition.stop();
        recognition.isListening = false;
    }
}

document.getElementById('sendButton').addEventListener('click', sendMessage);
document.getElementById('messageInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        sendMessage();
    }
});

document.getElementById('summaryButton').addEventListener('click', getSummary);

function testApiConnection() {
    fetch('/api/test')
    .then(response => response.json())
    .then(data => {
        const statusDiv = document.getElementById('apiStatus');
        const messageSpan = document.getElementById('apiStatusMessage');
        
        if (data.status === 'success') {
            statusDiv.style.display = 'none';
            console.log('API接続テスト成功:', data.response);
        } else {
            statusDiv.style.display = 'block';
            statusDiv.className = 'alert alert-danger';
            messageSpan.textContent = data.message || 'AI接続に問題があります';
        }
    })
    .catch(error => {
        console.error('API接続テストエラー:', error);
        const statusDiv = document.getElementById('apiStatus');
        const messageSpan = document.getElementById('apiStatusMessage');
        statusDiv.style.display = 'block';
        statusDiv.className = 'alert alert-danger';
        messageSpan.textContent = 'ネットワーク接続に問題があります';
    });
}

function sendMessage() {
    const input = document.getElementById('messageInput');
    const message = input.value.trim();
    
    if (!message) return;
    
    // ユーザーメッセージを表示
    addMessage(message, 'user');
    input.value = '';
    
    // APIに送信
    sendMessageToAPI(message);
}

function addMessage(content, type) {
    const messagesContainer = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}-message`;
    
    messageDiv.innerHTML = `
        <div class="message-avatar"></div>
        <div class="message-content">
            ${content}
        </div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    return messageDiv; // 作成されたメッセージ要素を返す
}

function addRetryButton() {
    const messagesContainer = document.getElementById('chatMessages');
    const retryDiv = document.createElement('div');
    retryDiv.className = 'message ai-message retry-message';
    retryDiv.innerHTML = `
        <div class="message-avatar"></div>
        <div class="message-content">
            <button class="btn btn-outline-primary btn-sm" onclick="retryLastMessage()">
                <i class="fas fa-redo me-2"></i>再試行
            </button>
        </div>
    `;
    messagesContainer.appendChild(retryDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function retryLastMessage() {
    // 再試行ボタンを削除
    const retryMessages = document.querySelectorAll('.retry-message');
    retryMessages.forEach(msg => msg.remove());
    
    // 最後のユーザーメッセージを再送信
    const userMessages = document.querySelectorAll('.user-message .message-content');
    if (userMessages.length > 0) {
        const lastMessage = userMessages[userMessages.length - 1].textContent;
        // 直接APIを呼び出す
        sendMessageToAPI(lastMessage);
    }
}

function sendMessageToAPI(message) {
    // 送信ボタンを無効化
    document.getElementById('sendButton').disabled = true;
    
    // 読み込み中のメッセージを表示
    const loadingMessage = addMessage('考え中...', 'ai');
    loadingMessage.classList.add('loading-message');
    
    // 入力行動メタデータを取得
    const inputMetadata = inputBehaviorTracker.getMetadata();
    
    // APIリクエストデータ
    const requestData = { 
        message: message,
        metadata: inputMetadata  // デジタル学習ツイン用データ
    };
    
    // AIの応答を取得
    fetch('/chat', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
    })
    .then(response => {
        // 読み込み中メッセージを削除
        const loadingMessages = document.querySelectorAll('.loading-message');
        loadingMessages.forEach(msg => msg.remove());
        
        if (!response.ok) {
            throw new Error(`HTTPエラー: ${response.status} ${response.statusText}`);
        }
        
        return response.json();
    })
    .then(data => {
        if (data.error) {
            addMessage('⚠️ ' + data.error, 'ai');
            addRetryButton();
        } else {
            addMessage(data.response, 'ai');
            conversationCount++;
            
            // デジタル学習ツインのインサイトを表示（開発時のみ）
            if (data.twin_insights && window.location.hostname === 'localhost') {
                console.log('学習ツイン分析:', data.twin_insights);
                displayTwinInsights(data.twin_insights);
            }
            
            if (data.suggest_summary) {
                document.getElementById('summaryButton').style.display = 'block';
            }
        }
        
        document.getElementById('sendButton').disabled = false;
    })
    .catch(error => {
        // 読み込み中メッセージを削除
        const loadingMessages = document.querySelectorAll('.loading-message');
        loadingMessages.forEach(msg => msg.remove());
        
        console.error('通信エラー詳細:', error);
        addMessage('⚠️ 通信エラーが発生しました: ' + error.message, 'ai');
        addRetryButton();
        document.getElementById('sendButton').disabled = false;
        
        // API接続テストを実行
        testApiConnection();
    });
}

function getSummary() {
    document.getElementById('summaryButton').disabled = true;
    
    fetch('/summary', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            alert('エラーが発生しました: ' + data.error);
        } else {
            document.getElementById('summaryContent').textContent = data.summary;
            document.getElementById('summarySection').style.display = 'block';
            document.getElementById('summaryButton').style.display = 'none';
        }
        document.getElementById('summaryButton').disabled = false;
    })
    .catch(error => {
        console.error('Error:', error);
        alert('通信エラーが発生しました。');
        document.getElementById('summaryButton').disabled = false;
    });
}

// デジタル学習ツイン統合
class LearningTwinIntegration {
    constructor() {
        this.messageStartTime = null;
        this.isTyping = false;
        this.setupTypingDetection();
    }
    
    setupTypingDetection() {
        const messageInput = document.getElementById('messageInput');
        if (messageInput) {
            messageInput.addEventListener('focus', () => {
                this.messageStartTime = Date.now();
            });
            
            messageInput.addEventListener('input', () => {
                this.isTyping = true;
            });
            
            messageInput.addEventListener('blur', () => {
                this.isTyping = false;
            });
        }
    }
    
    getResponseTime() {
        if (this.messageStartTime) {
            return (Date.now() - this.messageStartTime) / 1000;
        }
        return 5.0; // デフォルト値
    }
    
    getStudentId() {
        // セッションから学習者IDを取得（実装により異なる）
        return document.body.dataset.studentId || '1';
    }
    
    getCurrentUnit() {
        const unitBadge = document.querySelector('.badge');
        return unitBadge ? unitBadge.textContent : '';
    }
}

// 学習ツイン統合を初期化
const twinIntegration = new LearningTwinIntegration();

// 既存のsendMessage関数を拡張
const originalSendMessage = window.sendMessage;
window.sendMessage = function() {
    const messageInput = document.getElementById('messageInput');
    const message = messageInput.value.trim();
    
    // 元の関数を実行
    if (originalSendMessage) {
        return originalSendMessage();
    }
};

// 入力モード切り替え
function switchInputMode() {
    const mode = document.querySelector('input[name="inputMode"]:checked').id;
    
    document.getElementById('touchKeyboard').style.display = 'none';
    document.getElementById('flickKeyboard').style.display = 'none';
    document.getElementById('handwritingPanel').style.display = 'none';
    
    if (mode === 'modeKeyboard') {
        document.getElementById('touchKeyboard').style.display = 'block';
    } else if (mode === 'modeFlick') {
        document.getElementById('flickKeyboard').style.display = 'block';
    } else if (mode === 'modeHandwriting') {
        document.getElementById('handwritingPanel').style.display = 'block';
    }
}

// フリック入力の初期化
function initializeFlickInput() {
    const flickContainer = document.getElementById('flickKeys');
    flickContainer.innerHTML = '';
    flickContainer.style.display = 'grid';
    flickContainer.style.gridTemplateColumns = 'repeat(4, 1fr)';
    flickContainer.style.gap = '6px';
    flickContainer.style.maxWidth = '240px';
    flickContainer.style.margin = '0 auto';
    
    const keys = ['あ', 'か', 'さ', 'た', 'な', 'は', 'ま', 'や', 'ら', 'わ', '゛', '゜', '、', '☆'];
    
    keys.forEach(key => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'btn btn-outline-primary';
        btn.style.cssText = 'min-width: 50px; height: 50px; font-size: 1.1rem; font-weight: 500;';
        btn.textContent = key;
        btn.onclick = () => showFlickOptions(key, btn);
        flickContainer.appendChild(btn);
    });
    
    // フリックキーボードのコントロールボタン
    document.getElementById('flickBackspaceBtn').addEventListener('click', function() {
        const input = document.getElementById('messageInput');
        input.value = input.value.slice(0, -1);
        input.focus();
    });
    
    document.getElementById('flickClearBtn').addEventListener('click', function() {
        document.getElementById('messageInput').value = '';
        document.getElementById('messageInput').focus();
    });
}

// フリックオプション表示（簡易版：クリックで次の文字を表示）
let flickIndex = {};
function showFlickOptions(key, btn) {
    const options = inputAssistConfig.flick[key];
    if (!options) return;
    
    if (!flickIndex[key]) flickIndex[key] = 0;
    
    const char = options[flickIndex[key] % options.length];
    if (char && char !== '(' && char !== ')') {
        insertText(char);
    }
    
    flickIndex[key]++;
}

// 手書き入力の初期化
function initializeHandwriting() {
    canvas = document.getElementById('handwritingCanvas');
    if (!canvas) return;
    
    ctx = canvas.getContext('2d');
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.strokeStyle = '#000';
    
    // タッチ＆マウスイベント
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchmove', handleTouchMove);
    canvas.addEventListener('touchend', stopDrawing);
    
    // ボタンイベント
    document.getElementById('recognizeBtn').addEventListener('click', recognizeHandwriting);
    document.getElementById('clearCanvasBtn').addEventListener('click', clearCanvas);
}

function startDrawing(e) {
    isDrawing = true;
    const rect = canvas.getBoundingClientRect();
    ctx.beginPath();
    ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
}

function draw(e) {
    if (!isDrawing) return;
    const rect = canvas.getBoundingClientRect();
    ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
    ctx.stroke();
}

function stopDrawing() {
    isDrawing = false;
}

function handleTouchStart(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    isDrawing = true;
    ctx.beginPath();
    ctx.moveTo(touch.clientX - rect.left, touch.clientY - rect.top);
}

function handleTouchMove(e) {
    e.preventDefault();
    if (!isDrawing) return;
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    ctx.lineTo(touch.clientX - rect.left, touch.clientY - rect.top);
    ctx.stroke();
}

function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    document.getElementById('recognitionResult').textContent = '';
}

// 手書き認識（簡易版：ランダムにひらがなを返す）
function recognizeHandwriting() {
    const imageData = canvas.toDataURL('image/png');
    
    // 実際の認識は外部APIが必要ですが、ここでは簡易的にメッセージを表示
    const resultDiv = document.getElementById('recognitionResult');
    resultDiv.innerHTML = '<span class="text-info">手書き認識機能は開発中です。<br>ひらがなを書いて「認識」ボタンを押してください。</span>';
    
    // デモ用：ランダムな文字を挿入（実装時は削除）
    // const demoChars = ['あ', 'い', 'う', 'え', 'お', 'か', 'き', 'く', 'け', 'こ'];
    // const randomChar = demoChars[Math.floor(Math.random() * demoChars.length)];
    // insertText(randomChar);
    // resultDiv.innerHTML = `<span class="text-success">認識: ${randomChar}</span>`;
}

</script>
{% endblock %}```
</script>
{% endblock %}
