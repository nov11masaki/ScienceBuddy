{% extends "base.html" %}

{% block title %}予想を立てよう{% endblock %}

{% block content %}
<div class="chat-page">
    <div class="container-fluid">
        <div class="row">
            <!-- 左側: 対話画面 -->
            <div class="col-lg-7 chat-column">
                <div class="chat-header text-center mb-3">
                    <h2 class="mb-2">
                        <i class="fas fa-brain text-primary"></i>
                        予想を立てよう
                    </h2>
                    <div class="unit-display">
                        <span class="badge bg-primary fs-6">{{ unit }}</span>
                    </div>
                </div>
                
                <div class="task-section mb-3">
                    <div class="task-card">
                        <h5 class="task-title">
                            <i class="fas fa-clipboard-list"></i>
                            課題
                        </h5>
                        <p class="task-content">{{ task_content }}</p>
                    </div>
                </div>
                
                <div class="chat-container">
                    <div class="api-status" id="apiStatus" style="display: none;">
                        <div class="alert alert-warning">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span id="apiStatusMessage">AI接続を確認中...</span>
                            <button class="btn btn-sm btn-outline-secondary ms-2" onclick="testApiConnection()">
                                <i class="fas fa-sync"></i> 再テスト
                            </button>
                        </div>
                    </div>
                    
                    <div class="chat-messages" id="chatMessages">
                        <div class="message ai-message">
                            <div class="message-avatar"></div>
                            <div class="message-content">
                                {{ initial_ai_message }}
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="action-buttons text-center mt-3">
                    <button class="btn btn-success" id="summaryButton" style="display: none;">
                        <i class="fas fa-check me-2"></i>
                        予想をまとめる
                    </button>
                </div>
                
                <div class="summary-section" id="summarySection" style="display: none;">
                    <div class="summary-card">
                        <h5 class="summary-title">
                            <i class="fas fa-lightbulb"></i>
                            あなたの予想
                        </h5>
                        <div class="summary-content" id="summaryContent"></div>
                        <div class="text-center mt-3">
                            <a href="/experiment" class="btn btn-primary">
                                <i class="fas fa-flask me-2"></i>
                                実験を始める
                            </a>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 右側: 入力画面 -->
            <div class="col-lg-5 input-column">
                <div class="input-panel">
                    <div class="input-header mb-2">
                        <h4 class="mb-2" style="font-size: 1.1rem;">
                            <i class="fas fa-edit"></i> 入力エリア
                        </h4>
                        
                        <!-- 入力モード選択 -->
                        <div class="input-mode-selector mb-2">
                            <div class="btn-group btn-group-sm w-100" role="group">
                                <input type="radio" class="btn-check" name="inputMode" id="modeKeyboard" autocomplete="off" checked>
                                <label class="btn btn-outline-primary" for="modeKeyboard">
                                    <i class="fas fa-keyboard"></i> キーボード
                                </label>
                                
                                <input type="radio" class="btn-check" name="inputMode" id="modeFlick" autocomplete="off">
                                <label class="btn btn-outline-primary" for="modeFlick">
                                    <i class="fas fa-hand-pointer"></i> フリック
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- タッチキーボード -->
                    <div class="touch-keyboard-panel mb-2" id="touchKeyboard" style="display: block;">
                        <div class="keyboard-grid" id="hiraganaKeys">
                            <!-- JavaScriptで動的に生成 -->
                        </div>
                        <div class="keyboard-controls mt-1">
                            <button class="btn btn-sm btn-warning flex-fill me-1" id="backspaceBtn">
                                <i class="fas fa-backspace"></i> 消す
                            </button>
                            <button class="btn btn-sm btn-danger flex-fill" id="clearBtn">
                                <i class="fas fa-times"></i> 全消去
                            </button>
                        </div>
                    </div>
                    
                    <!-- フリック入力 -->
                    <div class="flick-keyboard-panel mb-2" id="flickKeyboard" style="display: none;">
                        <div class="flick-grid" id="flickKeys">
                            <!-- JavaScriptで動的に生成 -->
                        </div>
                        <div class="keyboard-controls mt-1">
                            <button class="btn btn-sm btn-warning flex-fill me-1" id="flickBackspaceBtn">
                                <i class="fas fa-backspace"></i> 消す
                            </button>
                            <button class="btn btn-sm btn-danger flex-fill" id="flickClearBtn">
                                <i class="fas fa-times"></i> 全消去
                            </button>
                        </div>
                    </div>
                    
                    <!-- 音声入力ボタン -->
                    <div class="voice-input-section mb-2" id="voiceInputSection">
                        <button class="btn btn-outline-primary w-100 btn-sm" id="voiceInputBtn">
                            <i class="fas fa-microphone"></i> 音声で入力
                        </button>
                        <div class="voice-input-status mt-2" id="voiceInputStatus" style="display: none;">
                            <div class="alert alert-info mb-0 py-1">
                                <i class="fas fa-microphone"></i>
                                <span id="voiceStatusText">音声を認識中...</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- テキスト入力 -->
                    <div class="text-input-section">
                        <textarea class="form-control mb-2" id="messageInput" rows="3" placeholder="あなたの考えを入力してください..." style="font-size: 0.95rem;"></textarea>
                        <button class="btn btn-primary w-100 btn-sm" id="sendButton">
                            <i class="fas fa-paper-plane me-2"></i>送信
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let conversationCount = 0;
let lastMessage = '';

// デジタル学習ツイン用の入力行動追跡
let inputBehaviorTracker = {
    startTime: null,
    keystrokes: [],
    pauses: 0,
    backspaces: 0,
    
    startTracking: function() {
        this.startTime = Date.now();
        this.keystrokes = [];
        this.pauses = 0;
        this.backspaces = 0;
    },
    
    recordKeystroke: function(key) {
        const now = Date.now();
        
        if (this.keystrokes.length > 0) {
            const timeSinceLastKey = now - this.keystrokes[this.keystrokes.length - 1].timestamp;
            if (timeSinceLastKey > 2000) { // 2秒以上の間隔はためらいとみなす
                this.pauses++;
            }
        }
        
        if (key === 'Backspace') {
            this.backspaces++;
        }
        
        this.keystrokes.push({
            key: key,
            timestamp: now
        });
    },
    
    getMetadata: function() {
        const totalTime = this.startTime ? (Date.now() - this.startTime) / 1000 : 0;
        const typingSpeed = this.keystrokes.length > 0 ? this.keystrokes.length / totalTime : 0;
        
        return {
            typing_speed: typingSpeed,
            pause_count: this.pauses,
            backspace_count: this.backspaces,
            thinking_time: totalTime
        };
    }
};

// 入力補助用の設定（シンプルなひらがなのみ）
const inputAssistConfig = {
    hiragana: [
        // 縦5行、右から「あいうえお」順
        ['わ', 'ら', 'や', 'ま', 'は', 'な', 'た', 'さ', 'か', 'あ'],
        ['を', 'り', '', 'み', 'ひ', 'に', 'ち', 'し', 'き', 'い'],
        ['ん', 'る', 'ゆ', 'む', 'ふ', 'ぬ', 'つ', 'す', 'く', 'う'],
        ['', 'れ', '', 'め', 'へ', 'ね', 'て', 'せ', 'け', 'え'],
        ['', 'ろ', 'よ', 'も', 'ほ', 'の', 'と', 'そ', 'こ', 'お'],
        // 特殊文字行
        ['゛', '゜', 'っ', 'ゃ', 'ゅ', 'ょ', '、', '。', ' ', '']
    ],
    flick: {
        'あ': ['あ', 'い', 'う', 'え', 'お'],
        'か': ['か', 'き', 'く', 'け', 'こ'],
        'さ': ['さ', 'し', 'す', 'せ', 'そ'],
        'た': ['た', 'ち', 'つ', 'て', 'と'],
        'な': ['な', 'に', 'ぬ', 'ね', 'の'],
        'は': ['は', 'ひ', 'ふ', 'へ', 'ほ'],
        'ま': ['ま', 'み', 'む', 'め', 'も'],
        'や': ['や', '(', 'ゆ', ')', 'よ'],
        'ら': ['ら', 'り', 'る', 'れ', 'ろ'],
        'わ': ['わ', 'を', 'ん', 'ー', '〜'],
        '、': ['、', '。', '!', '?', '…'],
        '☆': ['っ', 'ゃ', 'ゅ', 'ょ', 'ゎ']
    }
};

const currentUnit = "{{ unit }}";
let recognition = null;

// ページ読み込み時にAPI接続をテスト
document.addEventListener('DOMContentLoaded', function() {
    testApiConnection();
    
    // 入力補助の初期化
    initializeInputAssist();
    initializeFlickInput();
    
    // 入力モード切り替え
    document.querySelectorAll('input[name="inputMode"]').forEach(radio => {
        radio.addEventListener('change', switchInputMode);
    });
    
    // 入力フィールドにイベントリスナーを追加
    const messageInput = document.getElementById('messageInput');
    
    messageInput.addEventListener('focus', function() {
        inputBehaviorTracker.startTracking();
    });
    
    messageInput.addEventListener('keydown', function(e) {
        inputBehaviorTracker.recordKeystroke(e.key);
    });
    
    // 入力補助トグル
    document.getElementById('inputAssistToggle').addEventListener('change', function(e) {
        toggleInputAssist(e.target.checked);
    });
    
    // 音声入力ボタン
    document.getElementById('voiceInputBtn').addEventListener('click', startVoiceInput);
    
    // キーボードコントロールボタン（タッチキーボード用）
    const backspaceBtn = document.getElementById('backspaceBtn');
    const clearBtn = document.getElementById('clearBtn');
    
    if (backspaceBtn) {
        backspaceBtn.addEventListener('click', function() {
            const input = document.getElementById('messageInput');
            if (input.value.length > 0) {
                input.value = input.value.slice(0, -1);
            }
            input.focus();
        });
    }
    
    if (clearBtn) {
        clearBtn.addEventListener('click', function() {
            const input = document.getElementById('messageInput');
            input.value = '';
            input.focus();
        });
    }
});

// 入力補助の初期化
function initializeInputAssist() {
    // ひらがなキーボードを設定（5列グリッドレイアウト）
    const hiraganaContainer = document.getElementById('hiraganaKeys');
    hiraganaContainer.innerHTML = '';
    
    inputAssistConfig.hiragana.forEach(row => {
        row.forEach(char => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn btn-outline-primary touch-key';
            if (char === '') {
                // 空白セル
                btn.style.visibility = 'hidden';
                btn.textContent = ' ';
            } else if (char === '゛') {
                // 濁点ボタン
                btn.textContent = '゛゜';
                btn.style.fontSize = '0.9rem';
                btn.onclick = () => addDakuten();
            } else if (char === '゜') {
                // 半濁音ボタン（濁点と統合したので非表示）
                btn.style.visibility = 'hidden';
                btn.textContent = ' ';
            } else {
                btn.textContent = char;
                btn.onclick = () => insertText(char);
            }
            hiraganaContainer.appendChild(btn);
        });
    });
}

// 濁点・半濁音を追加
function addDakuten() {
    const input = document.getElementById('messageInput');
    const text = input.value;
    if (text.length === 0) return;
    
    const lastChar = text[text.length - 1];
    const dakutenMap = {
        'か': 'が', 'き': 'ぎ', 'く': 'ぐ', 'け': 'げ', 'こ': 'ご',
        'さ': 'ざ', 'し': 'じ', 'す': 'ず', 'せ': 'ぜ', 'そ': 'ぞ',
        'た': 'だ', 'ち': 'ぢ', 'つ': 'づ', 'て': 'で', 'と': 'ど',
        'は': 'ば', 'ひ': 'び', 'ふ': 'ぶ', 'へ': 'べ', 'ほ': 'ぼ',
        'ば': 'ぱ', 'び': 'ぴ', 'ぶ': 'ぷ', 'べ': 'ぺ', 'ぼ': 'ぽ'
    };
    
    if (dakutenMap[lastChar]) {
        input.value = text.slice(0, -1) + dakutenMap[lastChar];
        input.focus();
    }
}

// 入力補助の表示切り替え
function toggleInputAssist(enabled) {
    const keyboardDiv = document.getElementById('touchKeyboard');
    const voiceDiv = document.getElementById('voiceInputSection');
    
    if (enabled) {
        keyboardDiv.style.display = 'block';
        voiceDiv.style.display = 'block';
    } else {
        keyboardDiv.style.display = 'none';
        voiceDiv.style.display = 'none';
        stopVoiceInput();
    }
}

// テキストを挿入
function insertText(text) {
    const input = document.getElementById('messageInput');
    input.value += text;
    input.focus();
}

// 音声入力開始
function startVoiceInput() {
    console.log('音声入力開始ボタンがクリックされました');
    
    // Web Speech API のサポート確認
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert('お使いのブラウザは音声入力に対応していません。Chrome、Edge、Safariをお使いください。');
        console.error('Web Speech API not supported');
        return;
    }
    
    console.log('Web Speech API サポート確認OK');
    
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    
    if (recognition && recognition.isListening) {
        console.log('既に音声認識中のため停止します');
        stopVoiceInput();
        return;
    }
    
    try {
        recognition = new SpeechRecognition();
        recognition.lang = 'ja-JP';
        recognition.continuous = false;
        recognition.interimResults = true;
        
        console.log('SpeechRecognition オブジェクト作成完了');
        
        const statusDiv = document.getElementById('voiceInputStatus');
        const statusText = document.getElementById('voiceStatusText');
        const voiceBtn = document.getElementById('voiceInputBtn');
        
        console.log('DOM要素取得:', {statusDiv, statusText, voiceBtn});
        
        recognition.onstart = function() {
            console.log('音声認識開始');
            recognition.isListening = true;
            statusDiv.style.display = 'block';
            statusText.textContent = '音声を認識中...';
            voiceBtn.classList.add('btn-danger');
            voiceBtn.classList.remove('btn-outline-primary');
        };
    
    recognition.onresult = function(event) {
        let interimTranscript = '';
        let finalTranscript = '';
        
        for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
                finalTranscript += transcript;
            } else {
                interimTranscript += transcript;
            }
        }
        
        if (interimTranscript) {
            statusText.textContent = '認識中: ' + interimTranscript;
        }
        
        if (finalTranscript) {
            const input = document.getElementById('messageInput');
            input.value += finalTranscript;
            statusText.textContent = '認識完了: ' + finalTranscript;
        }
    };
    
    recognition.onerror = function(event) {
        console.error('音声認識エラー:', event.error);
        statusDiv.style.display = 'none';
        voiceBtn.classList.remove('btn-danger');
        voiceBtn.classList.add('btn-outline-primary');
        recognition.isListening = false;
        
        if (event.error === 'no-speech') {
            alert('音声が検出されませんでした。もう一度お試しください。');
        } else if (event.error === 'not-allowed') {
            alert('マイクの使用が許可されていません。ブラウザの設定を確認してください。');
        }
    };
    
    recognition.onend = function() {
        console.log('音声認識終了');
        setTimeout(() => {
            statusDiv.style.display = 'none';
            voiceBtn.classList.remove('btn-danger');
            voiceBtn.classList.add('btn-outline-primary');
            recognition.isListening = false;
        }, 1000);
    };
    
        console.log('音声認識を開始します');
        recognition.start();
    } catch (error) {
        console.error('音声認識エラー:', error);
        alert('音声認識の初期化に失敗しました: ' + error.message);
    }
}

// 音声入力停止
function stopVoiceInput() {
    if (recognition && recognition.isListening) {
        recognition.stop();
        recognition.isListening = false;
    }
}

document.getElementById('sendButton').addEventListener('click', sendMessage);
document.getElementById('messageInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        sendMessage();
    }
});

document.getElementById('summaryButton').addEventListener('click', getSummary);

function testApiConnection() {
    fetch('/api/test')
    .then(response => response.json())
    .then(data => {
        const statusDiv = document.getElementById('apiStatus');
        const messageSpan = document.getElementById('apiStatusMessage');
        
        if (data.status === 'success') {
            statusDiv.style.display = 'none';
            console.log('API接続テスト成功:', data.response);
        } else {
            statusDiv.style.display = 'block';
            statusDiv.className = 'alert alert-danger';
            messageSpan.textContent = data.message || 'AI接続に問題があります';
        }
    })
    .catch(error => {
        console.error('API接続テストエラー:', error);
        const statusDiv = document.getElementById('apiStatus');
        const messageSpan = document.getElementById('apiStatusMessage');
        statusDiv.style.display = 'block';
        statusDiv.className = 'alert alert-danger';
        messageSpan.textContent = 'ネットワーク接続に問題があります';
    });
}

function sendMessage() {
    const input = document.getElementById('messageInput');
    const message = input.value.trim();
    
    if (!message) return;
    
    // ユーザーメッセージを表示
    addMessage(message, 'user');
    input.value = '';
    
    // APIに送信
    sendMessageToAPI(message);
}

function addMessage(content, type) {
    const messagesContainer = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}-message`;
    
    messageDiv.innerHTML = `
        <div class="message-avatar"></div>
        <div class="message-content">
            ${content}
        </div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    return messageDiv; // 作成されたメッセージ要素を返す
}

function addRetryButton() {
    const messagesContainer = document.getElementById('chatMessages');
    const retryDiv = document.createElement('div');
    retryDiv.className = 'message ai-message retry-message';
    retryDiv.innerHTML = `
        <div class="message-avatar"></div>
        <div class="message-content">
            <button class="btn btn-outline-primary btn-sm" onclick="retryLastMessage()">
                <i class="fas fa-redo me-2"></i>再試行
            </button>
        </div>
    `;
    messagesContainer.appendChild(retryDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function retryLastMessage() {
    // 再試行ボタンを削除
    const retryMessages = document.querySelectorAll('.retry-message');
    retryMessages.forEach(msg => msg.remove());
    
    // 最後のユーザーメッセージを再送信
    const userMessages = document.querySelectorAll('.user-message .message-content');
    if (userMessages.length > 0) {
        const lastMessage = userMessages[userMessages.length - 1].textContent;
        // 直接APIを呼び出す
        sendMessageToAPI(lastMessage);
    }
}

function sendMessageToAPI(message) {
    // 送信ボタンを無効化
    document.getElementById('sendButton').disabled = true;
    
    // 読み込み中のメッセージを表示
    const loadingMessage = addMessage('考え中...', 'ai');
    loadingMessage.classList.add('loading-message');
    
    // 入力行動メタデータを取得
    const inputMetadata = inputBehaviorTracker.getMetadata();
    
    // APIリクエストデータ
    const requestData = { 
        message: message,
        metadata: inputMetadata  // デジタル学習ツイン用データ
    };
    
    // AIの応答を取得
    fetch('/chat', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
    })
    .then(response => {
        // 読み込み中メッセージを削除
        const loadingMessages = document.querySelectorAll('.loading-message');
        loadingMessages.forEach(msg => msg.remove());
        
        if (!response.ok) {
            throw new Error(`HTTPエラー: ${response.status} ${response.statusText}`);
        }
        
        return response.json();
    })
    .then(data => {
        if (data.error) {
            addMessage('⚠️ ' + data.error, 'ai');
            addRetryButton();
        } else {
            addMessage(data.response, 'ai');
            conversationCount++;
            
            // デジタル学習ツインのインサイトを表示（開発時のみ）
            if (data.twin_insights && window.location.hostname === 'localhost') {
                console.log('学習ツイン分析:', data.twin_insights);
                displayTwinInsights(data.twin_insights);
            }
            
            if (data.suggest_summary) {
                document.getElementById('summaryButton').style.display = 'block';
            }
        }
        
        document.getElementById('sendButton').disabled = false;
    })
    .catch(error => {
        // 読み込み中メッセージを削除
        const loadingMessages = document.querySelectorAll('.loading-message');
        loadingMessages.forEach(msg => msg.remove());
        
        console.error('通信エラー詳細:', error);
        addMessage('⚠️ 通信エラーが発生しました: ' + error.message, 'ai');
        addRetryButton();
        document.getElementById('sendButton').disabled = false;
        
        // API接続テストを実行
        testApiConnection();
    });
}

function getSummary() {
    document.getElementById('summaryButton').disabled = true;
    
    fetch('/summary', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            alert('エラーが発生しました: ' + data.error);
        } else {
            document.getElementById('summaryContent').textContent = data.summary;
            document.getElementById('summarySection').style.display = 'block';
            document.getElementById('summaryButton').style.display = 'none';
        }
        document.getElementById('summaryButton').disabled = false;
    })
    .catch(error => {
        console.error('Error:', error);
        alert('通信エラーが発生しました。');
        document.getElementById('summaryButton').disabled = false;
    });
}

// デジタル学習ツイン統合
class LearningTwinIntegration {
    constructor() {
        this.messageStartTime = null;
        this.isTyping = false;
        this.setupTypingDetection();
    }
    
    setupTypingDetection() {
        const messageInput = document.getElementById('messageInput');
        if (messageInput) {
            messageInput.addEventListener('focus', () => {
                this.messageStartTime = Date.now();
            });
            
            messageInput.addEventListener('input', () => {
                this.isTyping = true;
            });
            
            messageInput.addEventListener('blur', () => {
                this.isTyping = false;
            });
        }
    }
    
    getResponseTime() {
        if (this.messageStartTime) {
            return (Date.now() - this.messageStartTime) / 1000;
        }
        return 5.0; // デフォルト値
    }
    
    getStudentId() {
        // セッションから学習者IDを取得（実装により異なる）
        return document.body.dataset.studentId || '1';
    }
    
    getCurrentUnit() {
        const unitBadge = document.querySelector('.badge');
        return unitBadge ? unitBadge.textContent : '';
    }
}

// 学習ツイン統合を初期化
const twinIntegration = new LearningTwinIntegration();

// 既存のsendMessage関数を拡張
const originalSendMessage = window.sendMessage;
window.sendMessage = function() {
    const messageInput = document.getElementById('messageInput');
    const message = messageInput.value.trim();
    
    // 元の関数を実行
    if (originalSendMessage) {
        return originalSendMessage();
    }
};

// 入力モード切り替え
function switchInputMode() {
    const mode = document.querySelector('input[name="inputMode"]:checked').id;
    
    document.getElementById('touchKeyboard').style.display = 'none';
    document.getElementById('flickKeyboard').style.display = 'none';
    
    if (mode === 'modeKeyboard') {
        document.getElementById('touchKeyboard').style.display = 'block';
    } else if (mode === 'modeFlick') {
        document.getElementById('flickKeyboard').style.display = 'block';
    }
}

// フリック入力の初期化
function initializeFlickInput() {
    const flickContainer = document.getElementById('flickKeys');
    flickContainer.innerHTML = '';
    flickContainer.style.display = 'grid';
    flickContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
    flickContainer.style.gap = '8px';
    flickContainer.style.maxWidth = '220px';
    flickContainer.style.margin = '0 auto';
    
    // 4行×3列のレイアウト: あかさ / たなは / まやら / わ、。
    const keys = [
        'あ', 'か', 'さ',
        'た', 'な', 'は',
        'ま', 'や', 'ら',
        'わ', '、', '☆'
    ];
    
    keys.forEach(key => {
        const btn = document.createElement('div');
        btn.className = 'flick-key-container';
        btn.style.cssText = 'position: relative; min-width: 60px; height: 60px;';
        
        const mainBtn = document.createElement('button');
        mainBtn.type = 'button';
        mainBtn.className = 'btn btn-outline-primary flick-key';
        mainBtn.style.cssText = 'width: 100%; height: 100%; font-size: 1.1rem; font-weight: 500; position: relative;';
        mainBtn.textContent = key;
        
        // フリックオプションのツールチップを表示
        const tooltip = document.createElement('div');
        tooltip.className = 'flick-tooltip';
        tooltip.style.cssText = 'position: absolute; top: -50px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; white-space: nowrap; display: none; z-index: 1000;';
        
        const options = inputAssistConfig.flick[key];
        if (options && options.length > 1) {
            let tooltipText = '';
            if (options.length === 5) {
                tooltipText = `↑${options[1]} ←${options[3]} ${options[0]} →${options[2]} ↓${options[4]}`;
            } else {
                tooltipText = options.join(' ');
            }
            tooltip.textContent = tooltipText;
        }
        
        mainBtn.addEventListener('mouseenter', () => {
            if (options && options.length > 1) tooltip.style.display = 'block';
        });
        mainBtn.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
        });
        
        // タップでメイン文字、長押しでオプション表示
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        
        mainBtn.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            tooltip.style.display = 'block';
        });
        
        mainBtn.addEventListener('touchend', (e) => {
            tooltip.style.display = 'none';
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance < 10) {
                // タップ
                insertText(options[0]);
            } else {
                // フリック
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                let selectedChar = options[0];
                
                if (options.length === 5) {
                    if (angle > -45 && angle <= 45) {
                        // 右
                        selectedChar = options[2];
                    } else if (angle > 45 && angle <= 135) {
                        // 下
                        selectedChar = options[4];
                    } else if (angle > -135 && angle <= -45) {
                        // 上
                        selectedChar = options[1];
                    } else {
                        // 左
                        selectedChar = options[3];
                    }
                }
                
                if (selectedChar && selectedChar !== '(' && selectedChar !== ')') {
                    insertText(selectedChar);
                }
            }
        });
        
        // マウスクリックでメイン文字
        mainBtn.addEventListener('click', (e) => {
            if (e.type === 'click' && !('ontouchstart' in window)) {
                insertText(options[0]);
            }
        });
        
        btn.appendChild(mainBtn);
        btn.appendChild(tooltip);
        flickContainer.appendChild(btn);
    });
    
    // フリックキーボードのコントロールボタン
    const flickBackspaceBtn = document.getElementById('flickBackspaceBtn');
    const flickClearBtn = document.getElementById('flickClearBtn');
    
    if (flickBackspaceBtn) {
        flickBackspaceBtn.addEventListener('click', function() {
            const input = document.getElementById('messageInput');
            if (input.value.length > 0) {
                input.value = input.value.slice(0, -1);
            }
            input.focus();
        });
    }
    
    if (flickClearBtn) {
        flickClearBtn.addEventListener('click', function() {
            const input = document.getElementById('messageInput');
            input.value = '';
            input.focus();
        });
    }
}

</script>
{% endblock %}
